{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "On cherche notre meilleur k:\n",
      "\n",
      "65.71 % de précision avec k= 3 .\n",
      "\n",
      "69.33 % de précision avec k= 4 .\n",
      "\n",
      "71.45 % de précision avec k= 5 .\n",
      "\n",
      "71.07 % de précision avec k= 6 .\n",
      "\n",
      "71.7 % de précision avec k= 7 .\n",
      "\n",
      "72.19 % de précision avec k= 8 .\n",
      "\n",
      "72.94 % de précision avec k= 9 .\n",
      "\n",
      "73.32 % de précision avec k= 10 .\n",
      "\n",
      "73.19 % de précision avec k= 11 .\n",
      "\n",
      "73.69 % de précision avec k= 12 .\n",
      "\n",
      "74.06 % de précision avec k= 13 .\n",
      "\n",
      "73.82 % de précision avec k= 14 .\n",
      "\n",
      "73.94 % de précision avec k= 15 .\n",
      "\n",
      "74.06 % de précision avec k= 16 .\n",
      "\n",
      "73.94 % de précision avec k= 17 .\n",
      "\n",
      "74.31 % de précision avec k= 18 .\n",
      "\n",
      "Le k le plus précis est 18\n",
      "\n",
      "(temps d'exécution pour trouver le meilleur k: 6 min 33 s)\n",
      "\n",
      "\n",
      "On teste notre meilleur k pour vérifier qu'il est cohérent:\n",
      "\n",
      "88.82 % de précision avec k= 18 avec le dataset data.csv\n",
      "\n",
      "88.2 % de précision avec k= 18 avec le dataset preTest.csv\n",
      "\n",
      "(temps d'exécution pour vérifier notre meilleur k avec les deux dataset: 0 min 7 s)\n",
      "\n",
      "\n",
      "On détermine les classes de notre dataset inconnu:\n",
      "\n",
      "(temps d'exécution pour déterminer les classes du dataset inconnu 1 min 30 s)\n",
      "\n",
      "Labels Check : Successfull!\n",
      "(temps d'exécution total: 8 min 11 s)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# -*- coding: utf-8 -*-\n",
    "import random\n",
    "import time \n",
    "\n",
    "class KNN : #Je crée une classe Fleur afin de lui donner comme attribut toutes les valeurs qui lui sont attribuées \n",
    "    def __init__(self, coord_1, coord_2, coord_3, coord_4, coord_5, coord_6, classe):\n",
    "        self.coord_1=float(coord_1)\n",
    "        self.coord_2=float(coord_2)\n",
    "        self.coord_3=float(coord_3)\n",
    "        self.coord_4=float(coord_4)\n",
    "        self.coord_5=float(coord_5)\n",
    "        self.coord_6=float(coord_6)\n",
    "        self.classe = str(classe) \n",
    "        \n",
    "    def Affichage(self): #Cette fonction permet d'afficher toutes les données d'une fleur  \n",
    "        print(\"coord_1 =\",self.coord_1 ,\"\\ncoord_2 =\",self.coord_2,\n",
    "              \"\\ncoord_3 =\",self.coord_3, \"\\ncoord_4 =\", \n",
    "              self.coord_4, \"\\ncoord_5 =\",self.coord_5,\n",
    "              \"\\ncoord_6 =\",self.coord_6 ,\"\\nClasse :\", self.classe)\n",
    "\n",
    "#On crée notre liste des différentes classes possibles\n",
    "allLabels = ['classA','classB','classC','classD','classE']\n",
    "dim=len(allLabels)        \n",
    "#on train avec data, on teste avec pretest et on evalue avec finaltest\n",
    "\n",
    "#traitement du fichier comprenant toutes les données des fleurs\n",
    "def Extraire_Data(data):\n",
    "    with open(data, 'r') as file:\n",
    "        lines = file.readlines()\n",
    "        listeDeKNN=[]\n",
    "        for line in lines[:len(lines)-1]:#On navigue dns les lignes de notre fichier de données\n",
    "            valeur = line.split(\",\")#On sépare les lignes en fonction des virgules\n",
    "            fleur = KNN(valeur[0],valeur[1],valeur[2],valeur[3],valeur[4],valeur[5],valeur[6][:6])#on donne a notre fleur les bonnes coordonnées\n",
    "            listeDeKNN.append(fleur) #On remplit la liste avec toutes nos différentes fleurs \n",
    "    return listeDeKNN\n",
    "#fin du remplissage de la liste des données\n",
    "\n",
    "#traitement du fichier comprenant toutes les données des fleurs sauf qu'on ne connait pas leur classe\n",
    "def Extraire_Data_inconnu(data):\n",
    "    with open(data, 'r') as file:\n",
    "        lines = file.readlines()\n",
    "        listeDeKNN=[]\n",
    "        for line in lines[:len(lines)-1]:#On navigue dns les lignes de notre fichier de données\n",
    "            valeur = line.split(\",\")#On sépare les lignes en fonction des virgules\n",
    "            fleur = KNN(valeur[0],valeur[1],valeur[2],valeur[3],valeur[4],valeur[5],\"\")#on donne a notre fleur les bonnes coordonnées\n",
    "            listeDeKNN.append(fleur) #On remplit la liste avec toutes nos différentes fleurs \n",
    "    return listeDeKNN\n",
    "#fin du remplissage de la liste des données avec à chaque fois l'attribut classe vide\n",
    "\n",
    "#permet d'enregistrer sur fichier tous les labels trouvés\n",
    "def Enregistrer_Labels(nameFile,labels):\n",
    "    myFile = open(nameFile,\"w\")\n",
    "    for label in labels:\n",
    "        myFile.write(label+\"\\n\")\n",
    "    myFile.close()\n",
    "\n",
    "\n",
    "#permet d'afficher ma liste de data au cas ou j'en aurai besoin\n",
    "def Afficher_Data(listeDeKNN):\n",
    "    for i in range (len(listeDeKNN)):\n",
    "        listeDeKNN[i].Affichage()\n",
    "\n",
    "def Check_txt(nameFile,nbLines):\n",
    "    fd =open(nameFile,'r')\n",
    "    lines = fd.readlines()\n",
    "    count=0\n",
    "    for label in lines:\n",
    "    \tif label.strip() in allLabels:\n",
    "    \t\tcount+=1\n",
    "    \telse:\n",
    "    \t\tif count<nbLines:\n",
    "    \t\t\tprint(\"Wrong label line:\"+str(count+1))\n",
    "    \t\t\tbreak\n",
    "    if count<nbLines:\n",
    "    \tprint(\"Labels Check : fail!\")\n",
    "    else:\n",
    "    \tprint(\"Labels Check : Successfull!\")\n",
    "\n",
    "\n",
    "\n",
    "#Méthode qui calcule la distance euclidienne entre les 6 coordonnées de 2 fleurs\n",
    "#data= une fleur du dataset (data.csv)\n",
    "#inconnu= la fleur inconnue dont on cherche le type\n",
    "def Distance_Euclidienne(data,inconnu):\n",
    "    return ((data.coord_1-inconnu.coord_1)**2+(data.coord_2-inconnu.coord_2)**2+\n",
    "            (data.coord_3-inconnu.coord_3)**2+(data.coord_4-inconnu.coord_4)**2\n",
    "            +(data.coord_5-inconnu.coord_5)**2+(data.coord_6-inconnu.coord_6)**2)**0.5\n",
    "\n",
    "#Méthode qui retourne l'index de la liste où se trouve la plus grande valeur.\n",
    "#On a besoin de cette fonction à la fin de la méthode apprentissage où, après \n",
    "#avoir compté les occurences de chaque type de fleur dans les k sélectionnées,\n",
    "#on veut savoir quel type a le plus d'occurences. Mais comme on a deux listes\n",
    "#différentes, une liste qui répertorie les types et une autre les occurences,\n",
    "#on doit retourner l'index du max de la liste d'occurence pour la liste des types.\n",
    "def Max(liste):\n",
    "    index=0\n",
    "    Max=liste[0]\n",
    "    for i in range (len(liste)):\n",
    "        if(liste[i]>Max):\n",
    "            Max=liste[i]\n",
    "            index=i\n",
    "    return index\n",
    "\n",
    "#Cette fonction permet de sortir deux nouveaux dataset a partir d'un dataset pris en parametre\n",
    "#Elle permet de tester notre k avec les deux fichiers data et preTest en les divisant en 2 dataset chacun\n",
    "def melanger_dataset(data):\n",
    "    random.shuffle(data)\n",
    "    taille_dataset_test=int(0.8*len(data))\n",
    "    data_set_connu=[]\n",
    "    data_set_inconnu=[]\n",
    "    for i in range(taille_dataset_test):\n",
    "        data_set_connu.append(data[i])\n",
    "    for i in range(taille_dataset_test, len(data)):\n",
    "        data_set_inconnu.append(data[i])\n",
    "    return data_set_connu, data_set_inconnu\n",
    "        \n",
    "        \n",
    "def Trouver_Classe(data,inconnu,k):\n",
    "    distances_classees=[]\n",
    "    for i in range (len(data)):\n",
    "        distance_label=[]\n",
    "        distance=Distance_Euclidienne(data[i], inconnu)\n",
    "        distance_label.append(distance)\n",
    "        distance_label.append(data[i].classe)   \n",
    "        n=len(distances_classees)\n",
    "        if(n==0):\n",
    "            distances_classees.append(distance_label)\n",
    "            n+=1\n",
    "        \n",
    "        for i in range (n):\n",
    "            if (distance < distances_classees[i][0]):\n",
    "                distances_classees.insert(i,distance_label)\n",
    "                break\n",
    "            elif(i==n-1):\n",
    "                distances_classees.append(distance_label)\n",
    "    compteur=[0 for i in range(dim)]   \n",
    "    for j in range (k):\n",
    "        for index in range(dim):\n",
    "            if(distances_classees[j][1]==allLabels[index]):\n",
    "                #Au lieu d'incrémenter avec 1 à chaque fois que l'on trouve la même classe\n",
    "                #on nuance/pondère cette valeur en ajoutant un poids en fonction de la position de \n",
    "                #l'élément dans la liste des distances classées.\n",
    "                #C'est à dire que le premier élément de la liste aura un poids \n",
    "                #plus important et incrémentera le compteur correspondant \n",
    "                #à sa classe de manière significative\n",
    "                compteur[index]+=k-j   \n",
    "    #Maintenant, on cherche le type ayant été compté le plus de fois\n",
    "    label=allLabels[Max(compteur)]\n",
    "    return label\n",
    "\n",
    "#ici on va simuler qu'on ne connait pas les classes de tout le fichier preTest.csv \n",
    "#on va chercher ces classes a partir du fichier data.csv pour ensuite les comparer aux vraies \n",
    "#classes et obtenir un pourcentage de précision\n",
    "\n",
    "#On repete l'operation pour k allant de 3 a 12 afin de determiner le meilleur k\n",
    "def Choisir_k():\n",
    "    t0=time.time()\n",
    "    print(\"\\nOn cherche notre meilleur k:\\n\")\n",
    "    dataset_a_verifier=Extraire_Data(\"preTest.csv\");\n",
    "    dataset_connu=Extraire_Data(\"data.csv\");    \n",
    "    maxi=0\n",
    "    meilleur_k=0\n",
    "    for k in range (3,19):\n",
    "        labels=[]\n",
    "        count=0\n",
    "        for i in range (len(dataset_a_verifier)):\n",
    "            labels.append(Trouver_Classe(dataset_connu, dataset_a_verifier[i],k))\n",
    "            if(labels[i]==dataset_a_verifier[i].classe):\n",
    "                count+=1\n",
    "        precision=count/len(dataset_a_verifier)*100\n",
    "        round(precision,2)\n",
    "        print(round(precision,2),\"% de précision avec k=\",k,\".\\n\")\n",
    "        if(precision>maxi):\n",
    "            meilleur_k=k\n",
    "            maxi=precision\n",
    "    t1=time.time()\n",
    "    duree=t1-t0\n",
    "    minutes=int(duree//60)\n",
    "    secondes=round(duree%60)\n",
    "    print(\"Le k le plus précis est\", meilleur_k)\n",
    "    print(\"\\n(temps d'exécution pour trouver le meilleur k:\",minutes,\"min\",secondes,\"s)\\n\")\n",
    "    return meilleur_k    \n",
    "\n",
    "def test_k(k):\n",
    "    t0=time.time()\n",
    "    #On va prendre 20% de notre dataset data.csv et simuler qu'on cherche la classe de ces 20%\n",
    "    #à l'aide des 80% que l'on connait. On teste cela avec notre meilleur k trouvé au dessus.\n",
    "    \n",
    "    print(\"\\nOn teste notre meilleur k pour vérifier qu'il est cohérent:\\n\")\n",
    "    dataset=Extraire_Data(\"data.csv\");    \n",
    "    dataset_connu, dataset_a_verifier= melanger_dataset(dataset)\n",
    "    labels=[]\n",
    "    count=0\n",
    "    for i in range (len(dataset_a_verifier)):\n",
    "        labels.append(Trouver_Classe(dataset_connu, dataset_a_verifier[i],k))\n",
    "        if(labels[i]==dataset_a_verifier[i].classe):\n",
    "            count+=1\n",
    "    precision=count/len(dataset_a_verifier)*100\n",
    "    round(precision,2)\n",
    "    print(round(precision,2),\"% de précision avec k=\",k,\"avec le dataset data.csv\\n\")\n",
    "    \n",
    "    #Ici on prend 20% de notre dataset preTest.csv et on simule qu'on cherche la classe de ces 20%\n",
    "    #à l'aide des 80% que l'on connait. On teste cela avec notre meilleur k trouvé au dessus.\n",
    "    dataset=Extraire_Data(\"preTest.csv\");    \n",
    "    dataset_connu, dataset_a_verifier= melanger_dataset(dataset)\n",
    "    labels=[]\n",
    "    count=0\n",
    "    for i in range (len(dataset_a_verifier)):\n",
    "        labels.append(Trouver_Classe(dataset_connu, dataset_a_verifier[i],k))\n",
    "        if(labels[i]==dataset_a_verifier[i].classe):\n",
    "            count+=1\n",
    "    precision=count/len(dataset_a_verifier)*100\n",
    "    round(precision,2)\n",
    "    print(round(precision,2),\"% de précision avec k=\",k,\"avec le dataset preTest.csv\\n\")\n",
    "    t1=time.time()\n",
    "    duree=t1-t0\n",
    "    minutes=int(duree//60)\n",
    "    secondes=round(duree%60)\n",
    "    print(\"(temps d'exécution pour vérifier notre meilleur k avec les deux dataset:\",minutes,\"min\",secondes,\"s)\\n\")\n",
    "\n",
    "def Estim_label(data_connu, data_inconnu, k):\n",
    "    print(\"\\nOn détermine les classes de notre dataset inconnu:\\n\")\n",
    "    t0=time.time()\n",
    "    dataset_inconnu=Extraire_Data_inconnu(data_inconnu)\n",
    "    dataset_connu=Extraire_Data(data_connu)   \n",
    "    nbrLignes=len(dataset_inconnu)\n",
    "    labels=[]\n",
    "    for i in range (nbrLignes):\n",
    "        labels.append(Trouver_Classe(dataset_connu, dataset_inconnu[i],k))\n",
    "    t1=time.time()\n",
    "    duree=t1-t0\n",
    "    minutes=int(duree//60)\n",
    "    secondes=round(duree%60)\n",
    "    print(\"(temps d'exécution pour déterminer les classes du dataset inconnu\" ,minutes,\"min\",secondes,\"s)\\n\")\n",
    "    #permet de compter le nombre d'occurences total de chaque classe pour comparer mes résultats et verifier leur cohérence\n",
    "    '''\n",
    "    print(\"classA:\", labels.count(\"classA\"), \"classB:\", labels.count(\"classB\"),\n",
    "          \"classC:\", labels.count(\"classC\"), \"classD:\", labels.count(\"classD\"),\n",
    "          \"classE:\", labels.count(\"classE\"))\n",
    "    '''\n",
    "    nameFile=\"Labels_VANDERSTIGEL.txt\"\n",
    "    Enregistrer_Labels(nameFile,labels)\n",
    "    Check_txt(nameFile, nbrLignes)\n",
    "\n",
    "t=time.time()\n",
    "k = Choisir_k()\n",
    "test_k(k)\n",
    "Estim_label(\"preTest.csv\", \"finalTest.csv\", k)\n",
    "t1=time.time()\n",
    "duree=t1-t\n",
    "minutes=int(duree//60)\n",
    "secondes=round(duree%60)\n",
    "print(\"(temps d'exécution total:\" ,minutes,\"min\",secondes,\"s)\\n\")\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
